#include <new>

#ifndef GPU
    #include <cmath>
#endif

#include <Problem/AllDifferent.hh>
#include <Extra/Utils.hh>
#include <MDD/MDD.hh>

using namespace Problem;

__device__
std::size_t AllDifferent::State::getSizeStorage(const MDD *const mdd)
{
    return sizeof(int) * mdd->getLayersCount();
}

__device__
AllDifferent::State::State(State::Type type, std::size_t sizeStorage, std::byte * const storage) :
    Problem::State(type, sizeStorage, storage),
    selectedValues(sizeStorage / sizeof(int), reinterpret_cast<int*>(storage))
{
    if (this->type == State::Type::Root)
    {
        this->type = State::Type::Regular;
    }
}

__device__
AllDifferent::State & AllDifferent::State::operator=(AllDifferent::State const & other)
{
    assert(sizeStorage == other.sizeStorage);
    type = other.type;
    selectedValues = other.selectedValues;
    return *this;
}

__device__
bool AllDifferent::State::operator==(AllDifferent::State const & other) const
{
    assert(type == other.type);
    return selectedValues == other.selectedValues;
}

__device__
bool AllDifferent::State::isValueSelected(int value) const
{
    return Extra::Algorithms::binary_search( selectedValues.begin(), selectedValues.end(), value);
}

__device__
void AllDifferent::State::addToSelectedValues(int value)
{
    selectedValues.emplaceBack(value);
    Extra::Algorithms::sort( selectedValues.begin(), selectedValues.end());
}

__device__
void AllDifferent::State::next(int value, State * const child) const
{
    if (this->isValueSelected(value))
    {
        new (child) State(Problem::State::Type::Impossible, child->sizeStorage, child->storage);
    }
    else
    {
        *child = *this;
        child->addToSelectedValues(value);
    }
}

__host__
uint AllDifferent::getOptimalLayerWidth(uint variablesCount)
{
    // https://en.wikipedia.org/wiki/Combination
    // https://en.wikipedia.org/wiki/Gamma_function
    uint n = variablesCount;
    uint k = variablesCount / 2;
    double nFact;
    double kFact;
    double diffFact;
#ifdef __CUDA_ARCH__
    nFact = tgamma(n + 1);
    kFact =  tgamma(k + 1);;
    diffFact = tgamma(n - k + 1);
#else
    nFact = std::tgamma(n + 1);
    kFact = std::tgamma(k + 1);;
    diffFact = std::tgamma(n - k + 1);
#endif
    return static_cast<uint>(std::ceil(nFact / (kFact * diffFact)));
}
