#include <new>
#include <cstdio>

#include <MDD/MDD.hh>

__device__
MDD::MDD(uint width, uint countVars, Problem::Variable const * const vars) :
    width(width),
    layers(countVars + 1),
    IDNextNode(0)
{
    new (&layers[0]) Layer(1, vars[0].minValue, vars[0].maxValue);
    for(uint i = 1; i < countVars; i += 1)
    {
        new (&layers[i]) Layer(width, vars[i].minValue, vars[i].maxValue);
    }
    new (&layers[countVars]) Layer(1,0,0);
}

__device__
void MDD::initializeSeparation()
{
    uint indexLastLater = layers.size - 1;
    for(uint indexLayer = 0; indexLayer < indexLastLater; indexLayer += 1)
    {
        Layer & layer = layers[indexLayer];

        // Add one node
        layer.nodes.emplaceBack(IDNextNode++);

        // Add all outgoing edges
        for (int value = layer.minValue; value <= layer.maxValue; value += 1)
        {
            layer.edges[0].emplaceBack(0, value);
        }
    };

    // Last layer
    layers.back().nodes.emplaceBack(IDNextNode++);
}

__device__
void MDD::toGraphViz() const
{
    printf("digraph G\n");
    printf("{\n");
    printf("\n");
    printf("  node [shape=circle];\n");
    // Nodes
    for (uint indexLayer = 0; indexLayer < layers.size; indexLayer += 1)
    {
        printf("\n");
        printf("  {\n");
        printf("      rank = same;\n");
        auto const & nodes = layers[indexLayer].nodes;
        for (Node const * node = nodes.begin(); node != nodes.end(); node += 1)
        {
            printf("      %d;\n", node->ID);
        }
        printf("  }\n");
    }

    // Edges
    uint indexLastLater = layers.size - 1;
    for (uint indexLayer = 0; indexLayer < indexLastLater; indexLayer += 1)
    {
        printf("\n");
        Layer const & layer = layers[indexLayer];
        Layer const & nextLayer = layers[indexLayer + 1];
        auto const & nodes = layer.nodes;
        auto const & nextNodes = nextLayer.nodes;
        for (uint indexNode = 0; indexNode < nodes.getSize(); indexNode += 1)
        {
            uint idParentNode = nodes[indexNode].ID;
            auto const & edges = layer.edges[indexNode];
            for(uint indexEdge = 0; indexEdge < edges.getSize(); indexEdge += 1)
            {
                Edge & edge = edges[indexEdge];
                uint idChildNode = nextNodes.at(edge.to).ID;
                printf("  %d -> %d [label=\"%d\"];\n",idParentNode, idChildNode, edge.value);
            }
        }
    }
    printf("\n");
    printf("}\n");
}

__device__
void MDD::DFS(uint indexLayer, uint indexNode, Extra::Containers::RestrainedVector<int> & labels, bool print) const
{
    uint indexLastLater = layers.size - 1;
    if(indexLayer == indexLastLater)
    {
        if (print)
        {
            printf("%d",labels[0]);
            for (uint i = 1; i < indexLayer; i += 1)
            {
                printf(",%d",labels[i]);
            }
            printf("\n");
        }
    }
    else
    {
        auto const &edges = layers[indexLayer].edges[indexNode];
        for (uint indexEdge = 0; indexEdge < edges.getSize(); indexEdge += 1)
        {
            Edge const & edge = edges[indexEdge];
            labels.emplaceBack(edge.value);
            DFS(indexLayer + 1,  edge.to, labels, print);
            labels.popBack();
        }

    }
}

__device__
uint MDD::getLayersCount() const
{
    return layers.size;
}
